from dataclasses import dataclass
from typing import Any, Generic, TypeVar, TypeAlias, Literal, overload


_Any: TypeAlias = Any


class ComfyTypes:
    INT: TypeAlias = int
    """integer"""

    FLOAT: TypeAlias = float
    """real number"""

    STRING: TypeAlias = str
    """string"""

    BOOLEAN: TypeAlias = bool
    """boolean"""

    Any: TypeAlias = _Any

    SELECTION = Literal

    ### markmarkmark ###


_T = TypeVar("_T")


@dataclass(frozen=True)
class ComfyInput(Generic[_T]):
    node: "_Node"
    """node instance"""

    index: int
    """index of this input"""

    name: str
    """name of this input"""

    type: _T
    """type of this input"""

    value: Any


@dataclass(frozen=True)
class ComfyOutput(Generic[_T]):
    node: "_Node"
    """node instance"""

    index: int
    """index of this output"""

    name: str | None

    type: _T
    """type of this output"""


class _Node:
    _context = None  # for workflow

    def __init__(self, name: str):
        self.name = name
        self._inputs: list[ComfyInput] = []
        self._outputs: list[ComfyOutput] = []

    def _add_input(self, inp: ComfyInput):
        if self._context is None:
            self._inputs.append(inp)
        else:
            self._context._add_input(self, inp)
        return inp

    def _add_output(self, out: ComfyOutput):
        if self._context is None:
            self._outputs.append(out)
        else:
            self._context._add_output(self, out)
        return out

    @property
    def input_length(self) -> int:
        return len(self._inputs)

    @property
    def output_length(self) -> int:
        return len(self._outputs)

    def input(self, index: int | str) -> ComfyInput[Any]:
        if isinstance(index, int):
            return self._inputs[index]
        for inp in self._inputs:
            if inp.name == index:
                return inp
        raise IndexError(f"invalid index {index} for input")

    def output(self, index: int | str) -> ComfyOutput[Any]:
        if isinstance(index, int):
            return self._outputs[index]
        for out in self._outputs:
            if out.name is not None and out.name == index:
                return out
        for out in self._outputs:
            if out.type.__name__ == index:
                return out
        raise IndexError(f"invalid index {index} for output")

    __truediv__ = output  # self / n == self.output(n)
    __rtruediv__ = input  # n / self == self.input(n)


_WILL_BE_LINKED = object()
_NOT_GIVEN = object()


# AUTOGENERATED STUBS
